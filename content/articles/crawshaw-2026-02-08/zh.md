---
title: 再过八个月的智能体（agents）
date: '2026-02-10T10:03:30.537Z'
sourceUrl: 'https://crawshaw.io/blog/eight-more-months-of-agents'
lang: zh
---
*2026-02-08*

我在[一年多前](https://crawshaw.io/blog/programming-with-llms)写过一篇总结，记录我用 LLM 编程的经验；又在[八个月前](https://crawshaw.io/blog/programming-with-agents)为“智能体（agent）”时代更新过一次。从那之后变化很大，所以这里再做一次更新。

## 一年之内，智能体进步巨大

12 个月前 Claude Code 发布时，我们正好在原型化我们的第一个智能体 Sketch。运气很好，我刚好在起点就能参与其中、兴奋地见证它的诞生。那时它们对某些事情在某些时候确实能帮上忙！

但智能体的执行框架（agent harness）从那以后并没有太大改进。Sketch 在六个月前能做得很好的事情，今天最流行的一些智能体反而做不到。执行框架至关重要，这里面仍有大量创新空间，但就当下而言，它的有趣程度大概就像 1990 年代“主频爆炸”时期的编译器优化一样——重要，但不是最刺激的战场。

现在，一切都取决于模型。

说到模型：公开基准测试很多，但基本都被“刷”到没意义了。别看它们。显然顶尖模型公司内部有很好的评测，因为模型在质变意义上已经发生了巨大变化。去年二月，Claude Code 只能写我大约四分之一的代码；今年二月，最新的 Opus 模型能写我九成的代码。所有输出仍然需要仔细阅读、定期调整，但现在我可以、也确实会依赖模型来帮我做这些调整。

模型并没有出现什么“显眼的大跳跃”，不像当年 GPT-2 突然开始像在跟你对话那样。但编码模型把事情推进到“有用结果”的能力，显然经历了巨大的渐进式提升。（这些进展当然是定性的，但它们是我目前看到最积极的经济信号。）

在大公司，我的时间分配大概是 80% 读代码、20% 写代码。在创业公司，过去更接近 50/50。现在则是 95/5。

## IDE 明显在式微

IDE 的历史真的很奇怪。

一方面，IDE 显然是“正确答案”。我当然应该拥有一个开发环境，尽可能提供我能有效使用的信息与辅助。迄今为止我用过最棒的 IDE，是 Windows 2000 上的 Visual Studio C++ 6.0。我从未见过一个工具链能与其环境如此完整、如此一致。

自 1999 年那段辉煌时刻之后，我编程生涯里在 IDE 之外度过的时间，反而比在 IDE 里更多。现实是：编程环境就是一团乱麻。Unix 很好，但我们在一套已经负担过重的 Unix 概念上又硬生生加装了一个“哈尔的移动城堡”，不怎么妙。我当年在 VS6.0 时代用的 Win32 API 也是同样的故事：它还在，但上面、周围叠了一个巨大的烂摊子，而且你完全没法忽略。

后来 Copilot 出来了，IDE 似乎变得不可避免。你把 IDE 硬塞进你的环境里再痛苦也得做，因为 LLM 辅助的自动补全与编辑强到无法忽视。它让我的“敲字效率”提高了 50%，而我大量编程工作本来就受打字速度限制，所以效果非常巨大。

2021 年，IDE 赢了。

2026 年，我已经不再使用 IDE。

我曾经对“Copilot 未来”有多笃定，而仅仅不到四年，智能体又给了我一个更好的工具，带来的那种惊人的反差至今仍让我意外。

我今天唯一还在用的“类 IDE 功能”是跳转到定义（go-to-def），而 neovim 稍微配置一下就能做到。所以到了 2026 年，我又回到了 Vi。

Vi 今年 50 岁了。

## 使用非最顶尖模型，实际上是在害自己

和智能体一起工作，很大一部分是在摸清它们的边界。而这些边界此刻还在快速移动，这意味着你必须不断重新学习。但如果你为了省点钱去用像 Sonnet 这样的廉价模型，或二流的本地模型，你不仅仅是浪费时间，*你会学到错误的教训*。

我比任何人都希望本地模型成功。直到 mixtral 出现那天之前，我都觉得 LLM 没什么意思；那天我终于能在一台很贵的机器上，把它“勉强”跑起来。第一次把这种东西握在手里的瞬间，我才真正理解它的意义。而且我也知道本地模型最终会赢。某个时刻，前沿模型会遇到边际收益递减，本地模型会追上来，我们也就不必再受制于前沿模型。那会是美好的一天。但在那之前，除非你用最强的模型，否则你根本不知道模型究竟能做到什么。为 Opus 或 GPT-7.9-xhigh-with-cheese 之类的东西付高价吧。别担心，这种日子也就再持续几年。

## 内置的智能体沙盒并不好用

Claude Code 不断问“我可以运行 `cat foo.txt` 吗？”、Codex 不断说“我尝试了但在我这个非常精密的沙盒里没法 `go build`”，这简直是噩梦。你不得不把沙盒关掉；而一旦关掉，你就必须自己提供沙盒。我几乎把所有方案都试过了，我强烈建议：用一个全新的 VM。

## 我比以前拥有更多程序和服务

这也是我在做 [exe.dev](https://exe.dev/) 的原因。我需要一个 VM，里面跑着一个不受约束的智能体，我可以非常随意地启动它，然后输入一句话——那句话本来我可能会写进一个叫 TODO 的 Apple 备忘录里，然后就忘了。很多时候，Shelley 能把一句话变成一个有用的小程序。

我现在写程序比以往任何时候都更快乐，因为我想写但一直没时间写的那么多程序，真的都变成了现实。我希望能把这种快乐分享给那些害怕智能体带来变化的人。对恐惧本身我能理解；更广泛地说，我也害怕“社会里随取随用的智能”最终会走向什么结局。但在“写计算机程序”这个有限领域里，这些工具确实给我的工作带来了大量探索与乐趣。

## 我对反 LLM 论点已经极度脱节

新技术会带来很多挑战与合理的担忧。我每天都在尝试把智能体推到极限，所以每周都会看到它们灾难性失败好几次。重大变化也会改变劳动力市场，产生很多好坏参半的影响。1900 年，33% 的美国人住在农场，40% 从事农业；到 2000 年，住在农场的不足 1%，农业从业者也只有 1%。这对世界整体而言是好事：我们不用所有人都为了吃饭而劳作。（如果再往前一个世纪看，数字更夸张。）但在这个过程中确实会发生、也确实发生过许多痛苦与心碎。担心这些是正确的。

但相比对现实变化的审慎分析，我看到更多的是那种强硬的反 LLM 立场：一年前我还只是不同意，现在我已经完全无法理解了。这听起来就像有人说木工应该禁止电动工具。我非常欣赏手工工具木工与技艺的精进，但人们需要房子，框架工队显然就该用电圆锯。在我看来，这和“水是湿的”一样显而易见。

## 很多事情都必须改变

现在大多数软件的“形状”都不对；我们解决问题的大多数方式也都不对。

举个例子：Stripe Sigma。这是个不错的新产品，用来给你的 Stripe 数据库做 SQL 查询。它内置了一个小 LLM 来帮你写查询，但那个 LLM 并不好。我想要 Claude Code 或 Codex 来写我的查询。但 Stripe 在推出 API 之前，先做了一个很花哨的 Sigma UI，并把小助手集成进去了。SQL 的 REST 端点有个私有 alpha，我还没有权限用。于是我让智能体从零做了一套 ETL：它用标准的 Stripe API 把我账户的所有数据拉出来，建了一个本地 SQLite 数据库；现在我的智能体在这个库上做查询，比 Sigma 强得多。

我只打了三句话，就“实现”了整个 Stripe 产品（至少是它与我相关的部分）。它解决我的问题，比他们的产品更好。

这就是我们今天所处的世界。在这个新世界里，我每天不得不用的最糟糕产品就是云，所以我才在 [exe.dev](https://exe.dev/) 上做这个。它比看起来难得多，但这个产品存在的全部意义，就是让你永远不会觉得：你的智能体应该替你重写它的某一部分。

在这个过程中，我逐渐形成了一套编程哲学，并把它应用到所有事情上：**对智能体来说最好的软件，就是对程序员来说最好的软件**。传统上，为客户做产品的现实需求常常把我们推离这条哲学。产品经理们总得委婉地告诉工程师：你不是客户。现在这一点被彻底颠倒了：每个客户都有一个智能体，会为他们的产品写代码。做程序员喜欢的东西，所有人都会跟随。

希望这套哲学能在未来一年由 LLM 带来的巨变中继续存活下去。
